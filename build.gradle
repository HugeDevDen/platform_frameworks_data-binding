
buildscript {
    ext.rootFolder = project.projectDir
    apply from: 'propLoader.gradle'
    ext.addRepos(repositories)
    if (ext.config.addRemoteRepos) {
        dependencies {
            classpath "com.android.databinding:localizemaven:${config.extraPluginsVersion}"
        }
    }
    dependencies {
        classpath 'net.sf.proguard:proguard-gradle:5.2.1'
    }
}
subprojects {
    apply plugin: 'maven'
    if (config.addRemoteRepos) {
        apply plugin: 'com.android.databinding.localizemaven'
    }

    group = config.group
    version = config.version
    uploadArchives {
        repositories {
            mavenDeployer {
                repository(url: "file://${config.mavenRepoDir}")
            }
        }
    }
    buildscript {
        addRepos(repositories)
        dependencies {
            classpath "com.android.databinding:bintray:${config.extraPluginsVersion}"
        }
    }
}

if (config.addRemoteRepos) {
    localizeMaven {
        localRepoDir = file(config.megaRepoDir)
        otherRepoDirs = config.localRepositories
    }
}

task deleteRepo(type: Delete) {
    delete "${config.mavenRepoDir}/${config.group.replace('.', '/')}"
}

task deletePrebuildFolder(type: Delete) {
    delete "${config.prebuildFolder}"
}

task deleteEap(type: Delete) {
    delete "${config.eapOutDir}"
}


def buildExtensionsTask = project.tasks.create "buildExtensionsTask", Exec
buildExtensionsTask.workingDir file('extensions').getAbsolutePath()
buildExtensionsTask.commandLine './gradlew'
buildExtensionsTask.args 'clean', 'uploadArchives', '--info', '--stacktrace'
buildExtensionsTask.dependsOn subprojects.uploadArchives

def prepareExtensionPrebuilds = project.tasks.create "prepareExtensionPrebuilds", Exec
prepareExtensionPrebuilds.workingDir file('extensions').getAbsolutePath()
prepareExtensionPrebuilds.commandLine './gradlew'
prepareExtensionPrebuilds.args 'clean', 'preparePrebuilds', '--info', '--stacktrace'
prepareExtensionPrebuilds.dependsOn subprojects.uploadArchives

file('integration-tests').listFiles().findAll { it.isDirectory() }.each {
    println("Creating run test task for  ${it.getAbsolutePath()}.")
    def testTask = project.tasks.create "runTestsOf${it.getName().capitalize()}", Exec
    testTask.workingDir it.getAbsolutePath()
    //on linux
    testTask.commandLine './gradlew'
    testTask.args 'clean', 'connectedCheck', '--info', '--stacktrace'
    testTask.dependsOn subprojects.uploadArchives
    testTask.dependsOn buildExtensionsTask
}

task runIntegrationTests {
    dependsOn tasks.findAll { task -> task.name.startsWith('runTestsOf') }
}

task runAllTests {
    dependsOn runIntegrationTests
}

task preparePrebuilds() {
    dependsOn deletePrebuildFolder
    dependsOn prepareExtensionPrebuilds
}

allprojects {
    afterEvaluate { project ->
        runAllTests.dependsOn project.tasks.findAll {task -> task.name.equals('test')}
        runAllTests.dependsOn project.tasks.findAll {task -> task.name.equals('connectedCheck')}
        preparePrebuilds.dependsOn project.tasks.findAll {task -> task.name.startsWith('prebuild')}
    }
}

subprojects.uploadArchives.each { it.shouldRunAfter deleteRepo  }
subprojects.uploadArchives.each { it.shouldRunAfter deletePrebuildFolder  }
buildExtensionsTask.shouldRunAfter deleteRepo
tasks['runTestsOfMultiModuleTestApp'].dependsOn tasks['runTestsOfIndependentLibrary']


task rebuildRepo() {
    dependsOn deleteRepo
    dependsOn subprojects.uploadArchives
    dependsOn buildExtensionsTask
}

task copySamplesToEap(type : Copy) {
    mustRunAfter deleteEap
    from ("$projectDir/samples") {
        exclude "**/build"
        exclude "**/local.properties"
    }
    into "${config.eapOutDir}/samples"
}


task copyMavenRepoToEap(type : Copy) {
    mustRunAfter deleteEap
    dependsOn rebuildRepo
    from(config.mavenRepoDir)
    into "${config.eapOutDir}/${config.mavenRepoName}"
}

tasks.create(name : 'createEapConfigFile') << {
    def propsFile = new File("${config.eapOutDir}/databinding.properties")
    Properties props = new Properties()
    props.setProperty('version', config.version)
    props.setProperty('mavenRepoName', config.mavenRepoName)
    props.store(propsFile.newWriter(), null)
}


task batchEAP() {
    dependsOn deleteEap
    dependsOn copyMavenRepoToEap
    dependsOn copySamplesToEap
    dependsOn createEapConfigFile
}

def fullJar(project) {
    def localizeTask = project.parent.tasks.findByName('localizeDependencies')
    if (localizeTask != null) {
        localizeTask.dependsOn project.tasks.findByName('buildLicenseNotice')
    }

    if (config.version.endsWith('SNAPSHOT')) {
        return
    }
    def jarName = project.uploadArchives.repositories.mavenDeployer.pom.artifactId
    def workingDir = "${project.buildDir}/intermediates/fullJar"
    def fatJar = "${workingDir}/${jarName}-fat.jar"
    def proguardJar = "${workingDir}/${jarName}-proguard.jar"
    def jarJar = project.jar.archivePath

    project.configurations {
        jarJarArchives
    }

    project.tasks.create(name: 'fatJar', type: Jar) {
        baseName = jarName + '-fat'
        doFirst {
            file(workingDir).mkdirs()
        }
        def deps = new HashSet<ResolvedDependency>()
        project.configurations.compile.resolvedConfiguration.firstLevelModuleDependencies.each {
            if (!it.moduleGroup.startsWith('com.android.tools')) {
                deps.addAll(it.allModuleArtifacts)
            }
        }
        from { deps.findAll { !it.name.contains('baseLibrary')}.collect {
            it.file.isDirectory() ? it.file : project.zipTree(it.file)
        } } {
            exclude "META-INF/maven/**"
            exclude "META-INF/MANIFEST.MF"
            exclude "META-INF/LICENSE.txt"
            exclude "META-INF/NOTICE.txt"
            exclude "META-INF/services/javax.annotation.processing.Processor"
            exclude "**/*.stg"
        }
        archiveName "${baseName}.jar"
        destinationDir = new File(workingDir)
        with project.jar
    }
    project.tasks.create(name: 'proguard', type: proguard.gradle.ProGuardTask) {
        dependsOn 'fatJar'

        injars  fatJar
        outjars proguardJar

        configuration '../proguard.cfg'
    }

    project.tasks.create(name: 'jarJarFile') {
        dependsOn 'proguard'
        dependsOn project.jar
        def inputLibrary = proguardJar
        def outputLibrary = jarJar
        inputs.file(inputLibrary)
        outputs.file(outputLibrary)

        doLast {
            def jarJarLibrary = new File(config.externalPrebuiltsBase,
                    'tools/common/m2/repository/com/googlecode/jarjar/jarjar/1.3/jarjar-1.3.jar').
                    getCanonicalPath()
            // in Ant
            ant.taskdef(name: "jarjarIt",
                    classname: 'com.tonicsystems.jarjar.JarJarTask',
                    classpath: jarJarLibrary)
            // start jarjar task
            ant.jarjarIt(jarfile: outputLibrary) {
                // input is our inputLibrary
                zipfileset(src: inputLibrary)
                // rule to repackage antlr to new package
                rule pattern: 'org.antlr.**', result: 'com.google.repacked.antlr.@1'
                rule pattern: 'com.tunnelvisionlabs.**', result: 'com.google.repacked.tunnelvision.@1'
                // rule to repackage commons
                rule pattern: 'org.apache.**', result: 'com.google.repacked.apache.@1'
                rule pattern: 'kotlin.**', result: 'com.google.repacked.kotlin.@1'
            }
        }
    }

    project.uploadArchives {
        dependsOn 'jarJarFile'
        repositories {
            mavenDeployer {
                pom.whenConfigured { pom ->
                    pom.dependencies.removeAll { dep ->
                        def isBaseLibrary = dep.groupId == 'com.android.databinding' &&
                                dep.artifactId == 'baseLibrary'
                        def isGradle = dep.groupId == 'com.android.tools.build' &&
                                dep.artifactId == 'gradle'
                        return !isBaseLibrary && !isGradle
                    }
                }
            }
        }
    }
}
